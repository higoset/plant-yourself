"use strict";

var DEBUG = false;

var config;
var server;

var fs = require('fs');
var mime = require('mime');
var http = require('http');
var path = require('path');
var url = require('url');


var HttpDispatcher = function() {
  	this.listener = { get: [], post: [] };
  	this.errorListener = function() { };
  	this.staticFolderPrefix = "/static"; 
};

HttpDispatcher.prototype.getServer = function() {
	return server;
};

HttpDispatcher.prototype.setDebug = function(value) {
  	DEBUG = value; 
};

HttpDispatcher.prototype.initialize = function(value) {
	var n = 0;
	config = value;

	/*
		GET 
	*/
	for(var i = 0; i < config.get.length; i++) {
		n++;
		if (DEBUG) {
			console.log('Added file [GET method] ' + config.get[i].file);	
		}

		this.onGet(config.get[i], function(req, res, value) {		
			fs.readFile(value.path, function (err, data) {
				if (err) return;
				if (DEBUG) {
					console.log('Callback [GET] ' + value.file);	
				}
				res.writeHead(200, { "Content-Type": value.mime });
				res.write(data, "utf8");
				res.end();
			});
		}); 
	}
	
	/*
		POST
	*/
	for(var i = 0; i < config.post.length; i++) {
		n++;
		if (DEBUG) {
			console.log('Added file [POST method] ' + config.post[i].file);	
		}

		this.onPost(config.post[i], function(req, res, value) {
			fs.readFile(value.path, function (err, data) {
				if (err) return;
				if (DEBUG) {
					console.log('Callback [POST] ' + value.file);	
				}
				res.writeHead(200, { "Content-Type": value.mime });
				res.write(data, "utf8");
				res.end();
			});
		}); 
	}

	console.log("HttpDispatcher initialized (loaded " + n + " files)");	
};
 
HttpDispatcher.prototype.onError = function(cb) {
  	this.errorListener = cb; 
};
 
HttpDispatcher.prototype.staticListener = function(req, res) {
  	var parse = url.parse(req.url, true);
  	var filename = path.join(".", parse.pathname);
  	var errorListener = this.errorListener;
 
  	fs.readFile(filename, function(err, file) {
    	if(err) {
      		errorListener(req, res);
    	} else {
    		res.writeHeader(200, { "Content-Type": mime.lookup(filename) });
    		res.write(file, "binary");
    		res.end(); 
    	}
  	}); 
}; 
 
HttpDispatcher.prototype.on = function(method, obj, cb) { 
	this.listener[method][obj.file] = { value: obj, callback: cb };
};
 
HttpDispatcher.prototype.onGet = function(value, cb) {
  	this.on("get", value, cb); 
};
 
HttpDispatcher.prototype.onPost = function(value, cb) {
  	this.on("post", value, cb); 
};

HttpDispatcher.prototype.dispatch = function(req, res) {	
  	var parsedUrl = url.parse(req.url, true);
	if (DEBUG) {
		console.log("Required " + parsedUrl.pathname);
	}

  	if(parsedUrl.pathname.indexOf(this.staticFolderPrefix) == 0) {
    	this.staticListener(req, res);
  	} else {   
		var method = req.method.toLowerCase();
		if(this.listener[method][parsedUrl.pathname]) {
			if (DEBUG) {
				console.log("Found " + parsedUrl.pathname);
			}

		  	var o = this.listener[method][parsedUrl.pathname]; 
		  	o.callback(req, res, o.value);
		} else {
			this.errorListener(req, res); 
		}  
  	}
};

HttpDispatcher.prototype.create = function(port) {
	var self = this;

	server = http.createServer(function (req, res) {
		self.dispatch(req, res);
	}).listen(port);
};

module.exports = new HttpDispatcher();
